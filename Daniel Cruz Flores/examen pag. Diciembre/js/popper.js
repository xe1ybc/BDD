/ *
 Derechos de autor (C) Federico Zivolo 2018
 Distribuido bajo la Licencia MIT (los términos de la licencia están en http://opensource.org/licenses/MIT).
 * / (function (e, t) {'object' == typeof exports && 'undefined'! = typeof module? module.exports = t (): 'function' == typeof define && define.amd? define (t): e. Popper = t ()}) (esto, function () {'use strict'; function e (e) {return e && '[object Function]' === {}. ToString.call (e)} function t (e , t) {if (1! == e.nodeType) return []; var o = getComputedStyle (e, null); return t? o [t]: o} function o (e) {return'HTML '== = e.nodeName? e: e.parentNode || e.host} function n (e) {if (! e) return document.body; switch (e.nodeName) {case'HTML ': case'BODY': return e.ownerDocument.body; case '# document': return e.body;} var i = t (e), r = i.overflow, p = i.overflowX, s = i.overflowY; return / (auto | scroll | superposición) /. prueba (r + s + p)? e: n (o (e))} función r (e) {return 11 === e? re: 10 === e? pe: re || pe} function p (e) {if (! e) return document.documentElement;para (var o = r (10)? document.body: null, n = e.offsetParent; n === o && e.nextElementSibling;) n = (e = e.nextElementSibling) .offsetParent; var i = n && n.nodeName; return i && 'BODY'! == i && 'HTML'! == i? -1! == ['TD', 'TABLE']. indexOf (n.nodeName) && 'static' === t (n, ' position ')? p (n): n: e? e.ownerDocument.documentElement: document.documentElement} function s (e) {var t = e.nodeName; return'BODY'! == t && ('HTML' == = t || p (e.firstElementChild) === e)} function d (e) {return null === e.parentNode? e: d (e.parentNode)} function a (e, t) {if ( ! e ||! e.nodeType ||! t ||! t.nodeType) return document.documentElement; var o = e.compareDocumentPosition (t) & Node.DOCUMENT_POSITION_FOLLOWING, n = o? e: t, i = o? t : e, r = document.createRange (); r.setStart (n, 0), r.setEnd (i, 0); var l = r.commonAncestorContainer; if (e! == l && t! == l || n .contiene (i)) devolver s (l)? l: p (l); var f = d (e); devolver f.host?a(f.host,t):a(e,d(t).host )} función l (e) {var t = 1 <argumentos.longitud && void 0! == argumentos [1]? argumentos [1]: 'top', o = 'top' === t? 'scrollTop': 'scrollLeft ', n = e.nodeName; if (' 'BODY' === n || 'HTML' === n) {var i = e.ownerDocument.documentElement, r = e.ownerDocument.scrollingElement || i; return r [o]} devolver la función e [o]} f (e, t) {var o = 2 <argumentos.longitud && void 0! == argumentos [2] && argumentos [2], n = l (t, 'top'), i = l (t, 'left'), r = o? -1: 1; return e.top + = n * r, e.bottom + = n * r, e.left + = i * r, e.right + = i * r, e} función m (e, t) {var o = 'x' === t? 'Izquierda': 'Arriba', n = 'Izquierda' == o? 'Derecha': 'Abajo'; retorno parseFloat (e ['border' + o + 'Width'], 10) + parseFloat (e ['border' + n + 'Width'], 10)} function h (e, t, o,n) {return J (t ['offset' + e], t ['scroll' + e], o ['client' + e], o ['offset' + e], o ['scroll' + e] , r (10)? parseInt (o ['offset' + e]) + parseInt (n ['margin' + ('Height' === e? 'Top': 'Left')]) + parseInt (n [ 'margen' + ('Altura' === e? 'Parte inferior': 'Derecho')]): 0)} función c (e) {var t = e.body, o = e.documentElement, n = r ( 10) && getComputedStyle (o); return {altura: h ('Altura', t, o, n), ancho: h ('Ancho', t, o, n)}} función g (e) {return le ({ }, e, {right: e.left + e.width, bottom: e.top + e.height})} función u (e) {var o = {}; intente {if (r (10)) {o = e.getBoundingClientRect (); var n = l (e, 'top'), i = l (e, 'left'); o.top + = n, o.left + = i, o.bottom + = n, o. right + = i} else o = e.getBoundingClientRect ()} catch (t) {} var p = {left: o.left, top: o.top, width: o.right-o.left, height: o.bottom -o.top}, s = 'HTML' === e.nodeName? c (e.ownerDocument): {}, d = s.width || e.clientWidth || p.right-p.left, a = s.height || e.clientHeight || p.bottom-p. arriba, f = e.offsetWidth-d, h = e.offsetHeight-a; if (f || h) {var u = t (e); f- = m (u, 'x'), h- = m (u, 'y'), p.width- = f, p.height- = h} devolver la función g (p)} b (e, o) {var i = 2 <argumentos.longitud && void 0! == argumentos [ 2] && argumentos [2], p = r (10), s = 'HTML' === o.nodeName, d = u (e), a = u (o), l = n (e), m = t (o), h = parseFloat (m.borderTopWidth, 10), c = parseFloat (m.borderLeftWidth, 10); i && s && (a.top = J (a.top, 0), a.left = J (a.left , 0)); var b = g ({top: d.top-a.top-h, izquierda: d.left-a.left-c, width: d.width, height: d.height}); if (b.marginTop = 0, b.marginLeft = 0,! p && s) {var y = parseFloat (m.marginTop, 10), w = parseFloat (m.marginLeft, 10); b.top- = hy, b.bottom - = hy, b.left- = cw, b.right- = cw, b.marginTop = y, b.marginLeft = w} return (p &&! i? o.contains (l): o === l &&'BODY'! == l.nodeName) && (b = f (b, o)), b} función y (e) {var t = 1 <argumentos.longitud && void 0! == argumentos [1] && argumentos [1] , o = e.ownerDocument.documentElement, n = b (e, o), i = J (o.clientWidth, window.innerWidth || 0), r = J (o.clientHeight, window.innerHeight || 0), p = t? 0: l (o), s = t? 0: l (o, 'izquierda'), d = {arriba: pn.top + n.marginTop, izquierda: sn.left + n.marginLeft, ancho : i, altura: r}; devolver la función g (d)} w (e) {var n = e.nodeName; return'BODY '=== n ||' HTML '=== n?! 1:' corregido '=== t (e,' posición ') || w (o (e))} función E (e) {si (! e ||! e.parentElement || r ()) return document.documentElement; para (var o = e.parentElement; o && 'none' === t (o, 'transform');) o = o.parentElement; return o || document.documentElement} function v (e, t, i, r) {var p = 4 <argumentos.longitud && void 0! == argumentos [4] && argumentos [4], s = {arriba: 0, izquierda: 0}, d = p? E (e):a (e, t); if ('viewport' === r) s = y (d, p); else {var l; 'scrollParent' === r? (l = n (o (t)), 'BODY' === l.nodeName && (l = e.ownerDocument.documentElement)): 'window' === r? L = e.ownerDocument.documentElement: l = r; var f = b (l, d, p ); if ('HTML' === l.nodeName &&! w (d)) {var m = c (e.ownerDocument), h = m.height, g = m.width; s.top + = f.top- f.marginTop, s.bottom = h + f.top, s.left + = f.left-f.marginLeft, s.right = g + f.left} else s = f} i = i || 0; var u = 'número' == tipo de i; return s.left + = u? i: i.left || 0, s.top + = u? i: i.top || 0, s.right- = u? i: i .right || 0, s.bottom- = u? i: i.bottom || 0, s} function x (e) {var t = e.width, o = e.height; devolver t * o} function O (e, t, o, n, i) {var r = 5 <argumentos.longitud && void 0! == argumentos [5]? argumentos [5]: 0; if (-1 === e.indexOf ('auto' )) devuelve e; var p = v (o, n, r, i), s = {arriba: {ancho: ancho ancho, altura: t.top-p.top}, derecha: {ancho: ancho derecho -t.right, altura: p.altura}, parte inferior: {ancho: ancho p, altura: p. fondo-t.botoma}, izquierda: ancho: t.left-p.left, altura: altura.pdf}, d = Object.keys ( s) .map (function (e) {return le ({key: e}, s [e], {area: x (s [e])})}). sort (function (e, t) {return t .area-e.area}), a = d.filter (función (e) {var t = e.width, n = e.height; return t> = o.clientWidth && n> = o.clientHeight}), l = 0 <a.length? A [0] .key: d [0] .key, f = e.split ('-') [1]; devolver l + (f? '-' + f: '')} función L (e, t, o) {var n = 3 <argumentos.longitud && void 0! == argumentos [3]? Argumentos [3]: nulo, i = n? E (t): a (t, o); retorno b (o, i, n)} función S (e) {var t = getComputedStyle (e), o = parseFloat (t.marginTop) + parseFloat (t.marginBottom), n = parseFloat (t.marginLeft) + parseFloat ( t.marginRight), i = {ancho: e.offsetWidth + n, altura: e.offsetHeight + o}; return i} función T (e) {var t = {izquierda: 'derecha', derecha: 'izquierda', abajo: 'arriba', arriba: 'abajo'};return e.replace (/ left | right | bottom | top / g, function (e) {return t [e]})} function D (e, t, o) {o = o.split ('-') [ 0]; var n = S (e), i = {width: n.width, height: n.height}, r = -1! == ['right', 'left']. IndexOf (o), p = r? 'top': 'left', s = r? 'left': 'top', d = r? 'height': 'width', a = r? 'width': 'height'; return i [ p] = t [p] + t [d] / 2-n [d] / 2, i [s] = o === s? t [s] -n [a]: t [T (s)] , i} función C (e, t) {return Array.prototype.find? e.find (t): e.filter (t) [0]} función N (e, t, o) {if (Array.prototype .findIndex) return e.findIndex (function (e) {return e [t] === o}); var n = C (e, function (e) {return e [t] === o}); return e.indexOf (n)} función P (t, o, n) {var i = void 0 === n? t: t.slice (0, N (t, 'nombre', n)); devuelva i. forEach (function (t) {t ['function'] && console.warn ('`modifier.function` está en desuso, use` modifier.fn`!'); var n = t ['function '] || t.fn; t.enabled && e (n) && (o.offsets.popper = g (o.offsets.popper), o.offsets.reference = g (o.offsets.reference), o = n (o, t))}), o} función k () {if (! this.state.isDestroyed) {var e = {instancia: este, estilos: {}, arrowStyles: {}, atributos: {}, volteado :! 1, compensaciones: {}}; e.offsets.reference = L (this.state, this.popper, this.reference, this.options.positionFixed), e.placement = O (this.options.placement, e .offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), e.originalPlacement = e.placement, e.positionFixed = this.options. positionFixed, e.offsets.popper = D (this.popper, e.offsets.reference, e.placement), e.offsets.popper.position = this.options.positionFixed? 'fixed': 'absolute', e = P (this.modifiers, e), this.state.isCreated? this.options.onUpdate (e) :( this.state.isCreated =! 0, this.options.onCreate (e))}} función W (e, t) {return e.some (function (e) {var o = e.name, n = e.enabled; return n && o === t})} función H (e) {para (var t = [! 1, 'ms', 'Webkit', 'Moz', 'O'], o = e.charAt (0) .toUpperCase () + e.slice (1) , n = 0; n <t.length; n ++) {var i = t [n], r = i? '' + i + o: e; if ('undefined'! = typeof document.body.style [r ]) return r} return null} function B () {return this.state.isDestroyed =! 0, W (this.modifiers, 'applyStyle') && (this.popper.removeAttribute ('x-placement'), esto. popper.style.position = '', this.popper.style.top = '', this.popper.style.left = '', this.popper.style.right = '', this.popper.style.bottom = '', this.popper.style.willChange = '', this.popper.style [H ('transform')] = '', this.disableEventListeners (), this.options.removeOnDestroy && this.popper.parentNode.removeChild (this.popper), esta} función A (e) {var t = e.ownerDocument; return t? t.defaultView: window} function M (e, t, o, i) {var r = 'BODY' === e.nodeName, p = r? E.ownerDocument.defaultView: e; p.addEventListener (t, o, {passive:! 0}), r || M (n (p.parentNode), t, o, i), i.push (p)} función F (e, t, o, i) {o.updateBound = i, A (e) .addEventListener ('resize', o.updateBound, {pasivo: ! 0}); var r = n (e); devolver M (r, 'scroll', o.updateBound, o.scrollParents), o.scrollElement = r, o.eventsEnabled =! 0, o} function I () {this.state.eventsEnabled || (this.state = F (this.reference, this.options, this.state, this.scheduleUpdate))} function R (e, t) {return A (e) .removeEventListener (' resize ', t.updateBound), t.scrollParents.forEach (function (e) {e.removeEventListener (' scroll ', t.updateBound)}), t.updateBound = null, t.scrollParents = [], t.scrollElement = nulo, t.eventsEnabled =! 1,t} función U () {this.state.eventsEnabled && (cancelAnimationFrame (this.scheduleUpdate), this.state = R (this.reference, this.state))} function Y (e) {return ''! == e&&! isNaN (parseFloat (e)) && isFinite (e)} function j (e, t) {Object.keys (t) .forEach (function (o) {var n = ''; - 1! == ['width', 'altura', 'arriba', 'derecha', 'abajo', 'izquierda']. indexOf (o) && Y (t [o]) && (n = 'px'), e.style [o] = t [ o] + n})} función K (e, t) {Object.keys (t) .forEach (función (o) {var n = t [o] ;! 1 === n? e.removeAttribute (o) : e.setAttribute (o, t [o])})} función q (e, t, o) {var n = C (e, función (e) {var o = e.name; retorno o === t }), i = !! n && e.some (function (e) {return e.name === o && e.enabled && e.order <n.order}); if (! i) {var r = '`' + t + ' `'; console.warn ('` '+ o +' `'+'el modificador es requerido por el modificador '+ r +' para funcionar, asegúrese de incluirlo antes de '+ r +'! ')} return i} function G (e) {return'end' === e? 'start': 'start' === e? 'end': e} función V (e) {var t = 1 <argumentos.longitud && void 0! == argumentos [1] && argumentos [1], o = me.indexOf (e), n = me.slice (o + 1) .concat (me.slice (0, o)); devolver t? n.reverse (): n} función z (e, t, o, n) {var i = e .match (/ ((?: \ - | \ +)? \ d * \.? \ d *) (. *) /), r = + i [1], p = i [2]; if (! r) devuelva e; if (0 === p.indexOf ('%')) {var s; switch (p) {case '% p': s = o; break; case '%': case '% r ': predeterminado: s = n;} var d = g (s); devolver d [t] / 100 * r} if (' vh '=== p ||' vw '=== p) {var a; return a = 'vh' === p? J (document.documentElement.clientHeight, window.innerHeight || 0): J (document.documentElement.clientWidth, window.innerWidth || 0), a / 100 * r} return r} función _ (e, t, o,n) {var i = [0,0], r = -1! == ['right', 'left']. indexOf (n), p = e.split (/ (\ + | \ -) ​​/) .map (función (e) {return e.trim ()}), s = p.indexOf (C (p, función (e) {return-1! == e.search (/, | \ s /)} )); p [s] && - 1 === p [s] .indexOf (',') && console.warn ('Las compensaciones separadas por espacios en blanco están en desuso, use una coma (,) en su lugar.') ; var d = / \ s *, \ s * | \ s + /, a = -1 === s? [p]: [p.slice (0, s) .concat ([p [s] .split ( d) [0]]), [p [s] .split (d) [1]]. concat (p.slice (s + 1))]; devuelve a = a.map (función (e, n) { var i = (1 === n?! r: r)? 'height': 'width', p =! 1; return e.reduce (función (e, t) {return '' === e [e .length-1] && - 1! == ['+', '-']. indexOf (t)? (e [e.length-1] = t, p =! 0, e): p? (e [e.length-1] + = t, p =! 1, e): e.concat (t)}, []). map (function (e) {return z (e, i, t, o)} )}), a.forEach (función (e, t) {e.forEach (función (o, n) {Y (o) && (i [t] + = o * ('-' === e [n -1]? - 1:1))})}), i} función X (e, t) {var o, n = t.offset, i = e.placement, r = e.offsets, p = r.popper, s = r.reference , d = i.split ('-') [0]; retorno o = Y (+ n)? [+ n, 0]: _ (n, p, s, d), 'left' === d? (p.top + = o [0], p.left- = o [1]): 'right' === d? (p.top + = o [0], p.left + = o [1]): ' arriba '=== d? (p.left + = o [0], p.top- = o [1]):' bottom '=== d && (p.left + = o [0], p.top + = o [1]), e.popper = p, e} para (var Q = Math.min, Z = Math.round, $ = Math.floor, J = Math.max, ee = 'undefined'! = Typeof window && ' undefined '! = typeof document, te = [' Edge ',' Trident ',' Firefox '], oe = 0, ne = 0; ne <te.length; ne + = 1) if (ee && 0 <= navigator.userAgent. indexOf (te [ne])) {oe = 1; break} var i = ee && window.Promise, ie = i? function (e) {var t =! 1; return función () {t || (t =! 0 , window.Promise.resolve (). then (function () {t =! 1, e ()}))}}: function (e) {var t =! 1; return function () {t || (t =! 0,setTimeout (function () {t =! 1, e ()}, oe))}}, re = ee && !! (window.MSInputMethodContext && document.documentMode), pe = ee && / MSIE 10 / .test (navigator.userAgent), se = function (e, t) {if (! (e instanceof t)) lanza un nuevo TypeError ('No se puede llamar a una clase como una función')}, de = function () {function e (e, t) {for ( var o, n = 0; n <t.length; n ++) o = t [n], o.enumerable = o.enumerable ||! 1, o.configurable =! 0, 'value'in o && (o.writable =! 0), Object.defineProperty (e, o.key, o)} función de retorno (t, o, n) {return o && e (t.prototype, o), n && e (t, n), t}} () , ae = función (e, t, o) {return t en e? Object.defineProperty (e, t, {valor: o, enumerable:! 0, configurable:! 0, escribible:! 0}): e [t ] = o, e}, le = Object.assign || function (e) {para (var t, o = 1; o <argumentos.length; o ++) para (var n en t = argumentos [o], t) Object.prototype.hasOwnProperty.call (t, n) && (e [n] = t [n]); return e}, fe = ['auto-start ',' auto ',' auto-end ',' top-start ',' top ',' top-end ',' right-start ',' right ',' right-end ',' bottom- end ',' bottom ',' bottom-start ',' left-end ',' left ',' left-start '], me = fe.slice (3), he = {FLIP:' flip ', CLOCKWISE: 'en el sentido de las agujas del reloj', COUNTERCLOCKWISE: 'en sentido contrario a las agujas del reloj'}, ce = función () {función t (o, n) {var i = esto, r = 2 <argumentos.longitud && void 0! == argumentos [2]? argumentos [2] : {}; se (this, t), this.scheduleUpdate = function () {return requestAnimationFrame (i.update)}, this.update = ie (this.update.bind (this)), this.options = le ( {}, t.Defaults, r), this.state = {isDestroyed:! 1, isCreated:! 1, scrollParents: []}, this.reference = o && o.jquery? o [0]: o, this.popper = n && n.jquery? n [0]: n, this.options.modifiers = {}, Object.keys (le ({}, t.Defaults.modificadores, r.modificadores)). forEach (function (e) {i.options.modifiers [e] = le ({}, t.Defaults.modifiers [e] || {}, r.modifiers? r.modifiers [ e]: {})}), this.modifiers = Object.keys (this.options.modifiers) .map (function (e) {return le ({name: e}, i.options.modifiers [e])} ) .sort (function (e, t) {return e.order-t.order}), this.modifiers.forEach (function (t) {t.enabled && e (t.onLoad) && t.onLoad (i.reference, i .popper, i.options, t, i.state)}), this.update (); var p = this.options.eventsEnabled; p && this.enableEventListeners (), this.state.eventsEnabled = p} return de (t, [{key: 'update', value: function () {return k.call (this)}}, {key: 'destroy', value: function () {return B.call (this)}}, {key: 'enableEventListeners', value: function () {return I.call (this)}}, {key: 'disableEventListeners', value: function () {return U.call (this)}}]), t} (); devuelve ce.Utils = ('undefined '== typeof window? global: window) .PopperUtils, ce.placements = fe, ce.Defaults = {placement:' bottom ', positionFixed:! 1, eventsEnabled:! 0, removeOnDestroy:! 1, onCreate: function ( ) {}, onUpdate: function () {}, modifiers: {shift: {order: 100, enabled:! 0, fn: function (e) {var t = e.placement, o = t.split ('-' ) [0], n = t.split ('-') [1]; if (n) {var i = e.offsets, r = i.reference, p = i.popper, s = -1! == ['bottom', 'top']. indexOf (o), d = s? 'left': 'top', a = s? 'width': 'height', l = {start: ae ({}, d , r [d]), final: ae ({}, d, r [d] + r [a] -p [a])}; e.offsets.popper = le ({}, p, l [n] )} return e}}, offset: {order: 200, enabled:! 0, fn: X, offset: 0}, preventOverflow: {order: 300, enabled:! 0, fn: function (e, t) {var o = t.boundariesElement || p (e.instance.popper); e.instance.reference === o && (o = p (o)); var n = H ('transform'), i = e.instance. popper.style, r = i.top, s = i.left,d = i [n]; i.top = '', i.left = '', i [n] = ''; var a = v (e.instance.popper, e.instance.reference, t.padding, o, e.positionFixed); i.top = r, i.left = s, i [n] = d, t.boundaries = a; var l = t.priority, f = e.offsets.popper, m = { primario: función (e) {var o = f [e]; devolver f [e] <a [e] &&! t.escapeWithReference && (o = J (f [e], a [e])), ae ({ }, e, o)}, secundaria: función (e) {var o = 'derecha' === e? 'izquierda': 'arriba', n = f [o]; retorno f [e]> a [e ] &&! t.escapeWithReference && (n = Q (f [o], a [e] - ('right' === e? f.width: f.height))), ae ({}, o, n) }}; devolver l.forEach (función (e) {var t = -1 === ['left', 'top']. indexOf (e)? "secondary ':' primary '; f = le ({} , f, m [t] (e))}), e.offsets.popper = f, e}, prioridad: ['izquierda', 'derecha', 'arriba', 'inferior'], relleno: 5, fronterasElemento : 'scrollParent'}, keepTogether: {order: 400,habilitado:! 0, fn: función (e) {var t = e.offsets, o = t.popper, n = t.reference, i = e.placement.split ('-') [0], r = $ , p = -1! == ['top', 'bottom']. indexOf (i), s = p? 'right': 'bottom', d = p? 'left': 'top', a = p ? 'ancho': 'altura'; devolver o [s] <r (n [d]) && (e.offsets.popper [d] = r (n [d]) - o [a]), o [d ]> r (n [s]) && (e.offsets.popper [d] = r (n [s])), e}}, flecha: {orden: 500, habilitada:! 0, fn: función (e , o) {var n; if (! q (e.instance.modifiers, 'arrow', 'keepTogether')) devuelve e; var i = o.element; if ('string' == typeof i) {if ( i = e.instance.popper.querySelector (i) ,! i) return e;} else if (! e.instance.popper.contains (i)) return console.warn ('ADVERTENCIA: `arrow.element` debe ser hijo de su elemento popper! '), e; var r = e.placement.split (' - ') [0], p = e.offsets, s = p.popper, d = p.reference, a = -1 ! == ['izquierda', 'derecha ']. indexOf (r), l = a?' altura ':' ancho ', f = a?' Arriba ':' Izquierda ', m = f.toLowerCase (), h = a?' izquierda ':' arriba ', c = a?' abajo ':' derecha ', u = S (i) [l]; d [c] -u <s [m] && (e.offsets.popper [m] - = s [ m] - (d [c] -u)), d [m] + u> s [c] && (e.offsets.popper [m] + = d [m] + us [c]), e.offsets .popper = g (e.offsets.popper); var b = d [m] + d [l] / 2-u / 2, y = t (e.instance.popper), w = parseFloat (y ['margen '+ f], 10), E = parseFloat (y [' border '+ f +' Width '], 10), v = be.offsets.popper [m] -wE; retorno v = J (Q [s [l ] -u, v), 0), e.arrowElement = i, e.offsets.arrow = (n = {}, ae (n, m, Z (v)), ae (n, h, ''), n), e}, elemento: '[flecha x]'}, voltear: {orden: 600, habilitado:! 0, fn: función (e, t) {si (W (e.instance.modifiers, 'interior ')) devolver e; if (e.flipped && e.placement === e.originalPlacement) devolver e; var o = v (e.instance.popper, e.instance.reference, t.relleno, t.boundariesElement, e.positionFixed), n = e.placement.split ('-') [0], i = T (n), r = e.placement.split ('-') [1] | | '', p = []; switch (t.behavior) {case he.FLIP: p = [n, i]; break; case he.CLOCKWISE: p = V (n); break; case he.COUNTERCLOCKWISIS: p = V (n,! 0); break; predeterminado: p = t.behavior;} return p.forEach (función (s, d) {if (n! == s || p.length === d + 1) devuelva e; n = e.placement.split ('-') [0], i = T (n); var a = e.offsets.popper, l = e.offsets.reference, f = $, m = 'izquierda' === n && f (a.right)> f (l.left) || 'derecha' === n && f (a.left) <f (l.right) || 'top' === n && f (a.bottom)> f (l.top) || 'bottom' === n && f (a.top) <f (l.bottom), h = f (a.left) <f (o.left), c = f (a.right)> f (o.right), g = f (a.top) <f (o.top), u = f (a.bottom)> f (o.bottom), b = 'izquierda' === n && h || 'derecha' === n && c || 'arriba' === n && g || 'bottom '=== n && u, y = -1! == [' top ',' bottom ']. indexOf (n), w = !! t.flipVariations && (y &&' start '=== r && h || y &&' end '=== r && c ||! y &&' start '=== r && g ||! & &&' end '=== r & & u); (m || b || w) && (e.flipped =! 0, (m | | b) && (n = p [d + 1]), w && (r = G (r)), e.placement = n + (r? '-' + r: ''), e.offsets.popper = le ({}, e.offsets.popper, D (e.instance.popper, e.offsets.reference, e.placement)), e = P (e.instance.modifiers, e, 'flip'))}), e}, comportamiento: 'voltear', relleno: 5, fronterasElemento: 'viewport'}, interno: {orden: 700, habilitado:! 1, fn: función (e) {var t = ubicación.o, o = t. split ('-') [0], n = e.offsets, i = n.popper, r = n.reference, p = -1! == ['left', 'right']. indexOf (o), s = -1 === ['top', 'left']. indexOf (o); return i [p? 'left ':' top '] = r [o] - (s? i [p?' width ':' height ']: 0), e.placement = T (t), e.offsets.popper = g (i ), e}}, hide: {order: 800, enabled:! 0, fn: function (e) {if (! q (e.instance.modifiers, 'hide', 'preventOverflow')) return e; var t = e.offsets.reference, o = C (e.instance.modifiers, function (e) {return'preventOverflow '=== e.name}) .mites; if (t.bottom <o.top || t. izquierda> o.right || t.top> o.bottom || t.right <o.left) {if (! 0 === e.hide) devolver e; e.hide =! 0, e.attributes [ 'x-out-of-border'] = ''} else {if (! 1 === e.hide) devuelve e; e.hide =! 1, e.attributes ['x-out-of-bound' ] =! 1} return e}}, computeStyle: {order: 850, enabled:! 0, fn: function (e, t) {var o = tx, n = ty, i = e.offsets.popper, r = C (e.instance.modifiers, function (e) {return'applyStyle '=== e.name}). GpuAcceleration; void 0! == r && console.warn (' ADVERTENCIA:La opción `gpuAcceleration` se movió al modificador` computeStyle` y no será compatible con versiones futuras de Popper.js! '); var s, d, a = void 0 === r? t.gpuAcceleration: r, l = p ( e.instancia.popper), f = u (l), m = {posición: i.position}, h = {izquierda: $ (i.left), parte superior: Z (i.top), parte inferior: Z (i .bottom), derecha: $ (i.right)}, c = 'bottom' === o? 'top': 'bottom', g = 'right' === n? 'left': 'right', b = H ('transformar'); if (d = 'bottom' == c? 'HTML' === l.nodeName? -l.clientHeight + h.bottom: -f.height + h.bottom: h. arriba, s = 'derecho' == g? 'HTML' === l.nodeName? -l.clientWidth + h.right: -f.width + h.right: h.left, a && b) m [b] = 'translate3d (' + s + 'px,' + d + 'px, 0)', m [c] = 0, m [g] = 0, m.willChange = 'transform'; else {var y = 'bottom' = = c? -1: 1, w = 'derecho' == g? -1: 1; m [c] = d * y, m [g] = s * w, m.willChange = c + ','+ g} var E = {"x-placement": e.placement}; return e.attributes = le ({}, E, e.attributes), e.styles = le ({}, m, e.styles) , e.arrowStyles = le ({}, e.offsets.arrow, e.arrowStyles), e}, gpuAcceleration:! 0, x: 'bottom', y: 'right'}, applyStyle: {order: 900, enabled :! 0, fn: function (e) {return j (e.instance.popper, e.styles), K (e.instance.popper, e.attributes), e.arrowElement && Object.keys (e.arrowStyles) .length && j (e.arrowElement, e.arrowStyles), e}, onLoad: function (e, t, o, n, i) {var r = L (i, t, e, o.positionFixed), p = O (o. ubicación, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); devolver t.setAttribute ('x-placement', p), j (t, {position: o.positionFixed? 'arreglado': 'absoluto'}), o}, gpuAcceleration: void 0}}}, ce});arrowStyles = le ({}, e.offsets.arrow, e.arrowStyles), e}, gpuAcceleration:! 0, x: 'bottom', y: 'right'}, applyStyle: {order: 900, enabled:! 0 , fn: function (e) {return j (e.instance.popper, e.styles), K (e.instance.popper, e.attributes), e.arrowElement && Object.keys (e.arrowStyles) .length && j (e. arrowElemento, e.arrowStyles), e}, onLoad: function (e, t, o, n, i) {var r = L (i, t, e, o.positionFixed), p = O (o.placement, r , t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); devolver t.setAttribute ('x-placement', p), j (t, {position: o.positionFixed? 'fixed' : 'absoluto'}), o}, gpuAcceleration: void 0}}}, ce});arrowStyles = le ({}, e.offsets.arrow, e.arrowStyles), e}, gpuAcceleration:! 0, x: 'bottom', y: 'right'}, applyStyle: {order: 900, enabled:! 0 , fn: function (e) {return j (e.instance.popper, e.styles), K (e.instance.popper, e.attributes), e.arrowElement && Object.keys (e.arrowStyles) .length && j (e. arrowElemento, e.arrowStyles), e}, onLoad: function (e, t, o, n, i) {var r = L (i, t, e, o.positionFixed), p = O (o.placement, r , t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); devolver t.setAttribute ('x-placement', p), j (t, {position: o.positionFixed? 'fixed' : 'absoluto'}), o}, gpuAcceleration: void 0}}}, ce});Object.keys (e.arrowStyles) .length && j (e.arrowElement, e.arrowStyles), e}, onLoad: function (e, t, o, n, i) {var r = L (i, t, e, o .positionFixed), p = O (o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); devolver t.setAttribute ('x-placement', p), j (t, {posición: o.positionFixed? 'fixed': 'absolute'}), o}, gpuAcceleration: void 0}}}, ce});Object.keys (e.arrowStyles) .length && j (e.arrowElement, e.arrowStyles), e}, onLoad: function (e, t, o, n, i) {var r = L (i, t, e, o .positionFixed), p = O (o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); devolver t.setAttribute ('x-placement', p), j (t, {posición: o.positionFixed? 'fixed': 'absolute'}), o}, gpuAcceleration: void 0}}}, ce});
// # sourceMappingURL = popper.min.js.map